#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os, argparse
from datetime import datetime, timedelta, time
from timeparse import ParseNofDateTimeDelta, ParseTimeDelta, ParseDate
from logscanlib import Logs

INFO = {
#description
    'description' : """
logscan is a command-line-tool to get time-specific access to log-files.

logscan scans logs and print log-entries conditional on specified times and or durations. It can handle rotated and or gzipped logfiles and identifies different formats for timestamps of log-entries.
    """,
#usage
    'usage' : """
  logscan -h
  logscan logfile -i
  logscan logfile [OPTIONS]

Calculation of the period works on basis of datetimes and durations:
  no datetime; no duration:
                        whole log is printed
  one datetime; no duration:
                        period goes from datetime to
                        the end of the log
  two datetime; no duration:
                        period starts with the later
                        datetime and ends with the former
  no datetime; positive duration:
                        from begin of the log to the end
                        of the duration
  no datetime; negative duration:
                        from begin of the duration to end
                        of the log
  one datetime; positive duration:
                        from datetime to end of duration
  one datetime; negative duration:
                        from begin of duration to datetime
""",
#options:
    '-i' : 'print the number of logfiles, the start- and the end-time',
    '-d' : 'Print the log of a specified day.',
    '-f' : 'use FORMATSTRING to parse the date ("%%Y-%%m-%%d %%H:%%M:%%S")',
    '-g' : 'Only lines where PATTERN was found will be printed.',
#--time:
    '-t' : """Specifies daytime and date. The daytime and the date should be seperated by a whitespace. Date could be omitted. In that case logscan looks for the last log-entry for the given daytime.
The generic format for the daytime is HHMMSS. You could also use an arbitrary seperator: HH:MM:SS. (Using a seperator you don't need two-digit-values). You can omit seconds or seconds and minutes are not obliging. 0322 will be 03:22:00h or just 3 will be 03:00:00h.
The generic format for the date is DDMMYYYY. As well you can use a seperator and one-digit-values. Also the year or the year and the month could be missing. In that case the date will be completed by the actual year and month.
""",
#--durations:
    '-W' : """Specifies a duration of weeks, days, hours, minutes and seconds for the given N's in this order. Starting with weeks. Following N's are optional. To specify a 'negative' duration put a '-' in front of all N's.
Durations can be speciefied with all upper-case-options. All given durations are taken together, so that '-D 3 0 25' is the same as '-D 3 -M 25'.
""",
    '-D' : 'duration with first N as days.',
    '-H' : 'duration with first N as hours.',
    '-M' : 'duration with first N as minutes.',
    '-S' : 'duration with first N as seconds.',
}

def isfile(value):
    """Check if value is a file and raise an Error if not.
    """
    if os.path.isfile(value): return value
    else: raise argparse.ArgumentTypeError('{0} is no file'.format(value))

def main():
    """Commandline tool to get time-specific access to logfiles using logscanlib.
    """
    parser = argparse.ArgumentParser(
        prog='logscan',
        description=INFO['description'],
        usage=INFO['usage'],
    )
    parser.add_argument('logfile', type=isfile)
    parser.add_argument(
        '-i',
        '--info',
        action='store_true',
        default=False,
        help=INFO['-i'],
    )
    parser.add_argument(
        '-t',
        '--time',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-t']
    )
    parser.add_argument(
        '-W',
        '--weeks',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-W']
    )
    parser.add_argument(
        '-D',
        '--days',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-D']
    )
    parser.add_argument(
        '-H',
        '--hours',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-H']
    )
    parser.add_argument(
        '-M',
        '--minutes',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-M']
    )
    parser.add_argument(
        '-S',
        '--seconds',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-S']
    )
    parser.add_argument(
        '-d',
        '--date',
        action=ParseDate,
        nargs='+',
        metavar='N',
        help=INFO['-d']
    )
    parser.add_argument(
        '-f',
        '--strf',
        type=str,
        metavar='FORMATSTRING',
        help=INFO['-f']
    )
    parser.add_argument(
        '-g',
        '--grep',
        type=str,
        metavar='PATTERN',
        help=INFO['-g']
    )

    args = parser.parse_args()
    log = Logs(args.logfile, args.strf)
    log.period()
#    print log.end
#    print log.start

    if args.info:
        print ''
        print os.path.basename(log.path) + ':'
        print '{0} files'.format(log.number_files)
        print 'start: {0}'.format(log.start)
        print 'end: {0}'.format(log.end)
        print ''
        return

    if args.date:
        start = datetime.combine(args.date, time())
        end = datetime.combine(args.date + timedelta(days=1), time())
    else:
        delta = args.weeks + args.days + args.hours + args.minutes + args.seconds
        start = args.start_time
        styp = type(start).__name__
        end = args.end_time
        etyp = type(end).__name__

        if styp == 'timedelta': start = log.end - start
        elif styp == 'time': start = datetime.combine(log.end.date(), start)
        if etyp == 'timedelta': end = log.end - end
        elif etyp == 'time': end = datetime.combine(log.end.date(), end)

        if delta:
            if not start and not end:
                start = log.end - delta
                end = log.end
            elif start and not end:
                end = start + delta
            elif end and not start:
                start = end - delta
        else:
            if not start: start = log.start
            if not end: end = log.end

    lines = log.section(start, end)
    if lines:
        if args.grep: lines = [l for l in lines if args.grep in l]
        try: print ''.join(lines)[:-1]
        except IOError, KeyboardInterrupt: return
    else: print 'no log between {0} and {1}'.format(start, end)

if __name__ == "__main__":
    main()

