#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os
import sys
import re
import argparse
from datetime import datetime
from datetime import time
from datetime import timedelta

from timeparse import AppendDateTimeOrTime
from timeparse import ParseDateTimeOrTime
from timeparse import ParseTimeDelta
from timeparse import ParseDate
from logscanlib import RotatedLogs


CONFIGFILES = (
    'logscan.conf',
    '/usr/local/etc/logscan.conf',
    '/usr/etc/logscan.conf',
    )

TIMECODES = list()
for file in [f for f in CONFIGFILES if os.path.isfile(f)]:
    with open(file) as f:
        TIMECODES += [f.rstrip('\n') for f in file if not re.match('[#\n ]+', f)]

INFO = {
    'description' : """
logscan is a command-line-tool to get time-specific access to log-files.

logscan scans logs and print log-entries conditional on specified times
and durations. It can handle rotated and gzipped logfiles and identifies
different formats for timestamps of log-entries.

The calculation of a period works on basis of datetimes and durations:
  no datetime; no duration:
                        whole log is printed
  one datetime; no duration:
                        period goes from datetime to
                        the end of the log
  two datetime; no duration:
                        period starts with the first and
                        ends with the second datetime
  no datetime; positive duration:
                        from begin of the log to the end
                        of the duration
  no datetime; negative duration:
                        from begin of the duration to end
                        of the log
  one datetime; positive duration:
                        from datetime to end of duration
  one datetime; negative duration:
                        from begin of duration to datetime
    """,

    'usage' : """
  logscan -h
  logscan logfile -i
  logscan logfile [OPTIONS]
""",

    '-i' : 'print the number of logfiles, the start- and the end-time',
    '-d' : 'Print the log of a specified day.',
    '-f' : 'use FORMATSTRING to parse the date ("%%Y-%%m-%%d %%H:%%M:%%S")',
    '-g' : 'Only lines where PATTERN was found will be printed.',

    '-t' : """The first VALUE as date, second as daytime. The Date could be omitted. In that case logscan takes the date of the last log-entry.
The generic format for the daytime is HHMMSS. You could also use an arbitrary seperator: HH:MM:SS (doing so you don't need two-digit-values). Seconds or seconds and minutes are not obliging. 0322 will be 03:22:00h or just 3 will be 03:00:00h.
The generic format for the date is DDMM[YY]YY. As well you can use a seperator and one-digit-values. Also the year or the year and the month could be missing. In that case the date will be completed by the actual year and month.
""",

    '-W' : """Specifies a duration of weeks, days, hours, minutes and seconds for the given N's in this order. Starting with weeks. Following N's are optional. To specify a 'negative' duration put a '-' in front of all N's.
Durations can be speciefied with all upper-case-options. All given durations are taken together, so that '-D 3 0 25' is the same as '-D 3 -M 25'.
""",
    '-D' : 'duration with first N as days.',
    '-H' : 'duration with first N as hours.',
    '-M' : 'duration with first N as minutes.',
    '-S' : 'duration with first N as seconds.',
    }

def isfile(value):
    """Check if value is a file and raise an Error if not.
    """
    if os.path.isfile(value): return value
    else: raise argparse.ArgumentTypeError('{0} is no file'.format(value))


class Logscan:
    def __init__(self):
        self.start = None
        self.end = None
        self.parser = argparse.ArgumentParser(
            prog='logscan',
            description=INFO['description'],
            usage=INFO['usage'],
            formatter_class=argparse.RawDescriptionHelpFormatter,
            )
        self.parser.add_argument(
            'logfile',
            type=argparse.FileType('rb', 1),
            nargs='?',
            default='-'
            )
        self.parser.add_argument(
            '-i',
            '--info',
            action='store_true',
            default=False,
            help=INFO['-i'],
            )
        self.parser.add_argument(
            '-f',
            '--format',
            type=str,
            metavar='FORMATSTRING',
            help=INFO['-f']
            )
        self.parser.add_argument(
            '-g',
            '--grep',
            type=str,
            metavar='PATTERN',
            help=INFO['-g']
            )
        self.parser.add_argument(
            '-d',
            '--date',
            action=ParseDate,
            nargs='+',
            metavar='N',
            help=INFO['-d']
            )
        self.parser.add_argument(
            '-t',
            '--time',
            action=AppendDateTimeOrTime,
            nargs='+',
            metavar='VALUE',
            help=INFO['-t']
            )
        self.parser.add_argument(
            '-W',
            '--weeks',
            action=ParseTimeDelta,
            nargs='+',
            default=timedelta(),
            metavar='N',
            help=INFO['-W']
            )
        self.parser.add_argument(
            '-D',
            '--days',
            action=ParseTimeDelta,
            nargs='+',
            default=timedelta(),
            metavar='N',
            help=INFO['-D']
            )
        self.parser.add_argument(
            '-H',
            '--hours',
            action=ParseTimeDelta,
            nargs='+',
            default=timedelta(),
            metavar='N',
            help=INFO['-H']
            )
        self.parser.add_argument(
            '-M',
            '--minutes',
            action=ParseTimeDelta,
            nargs='+',
            default=timedelta(),
            metavar='N',
            help=INFO['-M']
            )
        self.parser.add_argument(
            '-S',
            '--seconds',
            action=ParseTimeDelta,
            nargs='+',
            default=timedelta(),
            metavar='N',
            help=INFO['-S']
            )

    def process(self):
        self.args = self.parser.parse_args()
        self.log = RotatedLogs(self.args.logfile, self.args.format, TIMECODES)
        self.args.weeks += self.args.days + self.args.hours + self.args.minutes + self.args.seconds

        if self.args.info: self.info()
        elif self.args.date: self.date()
        elif self.args.time and self.args.weeks: self.time_duration()
        elif self.args.time: self.time()
        elif self.args.weeks: self.duration()

        self.print_log()

    def prepare_times(self):
        for t in self.args.time:
            if isinstance(t, time):
                index = self.args.time.index(t)
                self.args.time[index] = datetime.combine(self.log.end.date(), t)

    def info(self):
        print ''
        print os.path.basename(self.log.name) + ':'
        print '  {0} files'.format(self.log.quantity)
        print '  starts: {0}'.format(self.log.start.strftime('%d.%m.%Y %H:%M:%S'))
        print '  ends: {0}'.format(self.log.end.strftime('%d.%m.%Y %H:%M:%S'))
        print ''
        sys.exit()

    def date(self):
        self.start = datetime.combine(self.args.date, time())
        self.end = datetime.combine(self.args.date + timedelta(days=1), time())

    def time_duration(self):
        self.prepare_times()
        if self.args.weeks > timedelta(0):
            self.start = self.args.time[0]
            self.end = self.args.time[0] + self.args.weeks
        else:
            self.start = self.args.time[0] + self.args.weeks
            self.end = self.args.time[0]

    def time(self):
        self.prepare_times()
        if len(self.args.time) is 1:
            self.start = self.args.time[0]
            self.end = self.log.end
        else:
            self.start = self.args.time[0]
            self.end = self.args.time[1]

    def duration(self):
        if self.args.weeks > timedelta(0):
            self.start = self.log.start
            self.end = self.log.start + self.args.weeks
        else:
            self.start = self.log.end + self.args.weeks
            self.end = self.log.end     #TODO: self.log.end will safe the last entry!

    def print_log(self):
        lines = self.log.get_section(self.start, self.end)

        if not lines:
            print 'no entries between {0} and {1}'.format(self.start, self.end)

        for line in lines:
            if self.args.grep and not self.args.grep in line: continue
            print line,


if __name__ == "__main__":
    logscan = Logscan()
    try: logscan.process()
    except KeyboardInterrupt: print KeyboardInterrupt.__name__


