#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os, argparse
from datetime import datetime, timedelta, time
from timeparse import ParseNofDateTimeDelta, ParseTimeDelta, ParseDate
from logscanlib import Logs

INFO = {
    'description' : """Logscan is a command-line-tool to get time-specific access to log-files.

Logscan can handle rotated logfiles with format "filename, filename.1, filename.2...". Also gzipped files are processed. Different date-time-formats are supported. Individual formats can be specified.
    """,
    'usage' : """
  logscan -h
  logscan logfile -i
  logscan logfile [OPTIONS]

exemples:
  logscan logfile -H 4 30  or  logscan logfile -t 4 30
                        starts 4h and 30min before last entry,
                        ends with the last entry
  logscan logfile -s 0105 2210 -m 50
                        from 5. Jan 22:10h to 5. Jan 23:00h
  logscan logfile -e 23 -w 2 0 5
                        starts 2 weeks and 5h before 23:00h,
                        ends at 23:00h
                        (with date of the last entry)
""",
    '-i' : 'print the number of logfiles, the start- and the end-time',
    '-s' : '''If there are two VALUES the first one is interpreted as an expression for a date and the second one for a time. If there is only one VALUE it is taken as an expression for a time and the date will be supplemented with the date of the last entry of the logfile.
VALUES can be given in various formats.
Exemples for dates are:
120123 --> 23.1.2012, 12:0123  --> 23.1.2012, 12-01-23  --> 23.1.2012, 20120123  --> 23.1.2012, 12-1-23  --> 23.1.2012.
Missing values will be complement to the last possible date in the past. For the following exemples we take the 16.01.2012 as the actual date:
03 --> 03.01.2012; 22 --> 22.12.2011; 0315 --> 15.03.2011
Times are handled in a similar way. But when you dont get at least three numbers out of the VALUE, then the given ones are taken first as hour, second as minutes.
For exemple: 120530, 12;5;30 or 1205-30 are all taken as 12:05:30 o'clock. 1205 or 12:05 is 12:05:00, and 12 is simple 12:00:00. You are free to use any delimiter you want. Or no delimiter. But then you have to care to use only double-digit numbers like "05".
The datetime you get will specify the start of the output. So you can use -s with only a single digit and you get the log of the day of the last log-entry from the hour of the digit on.''',
    '-e' : 'works the same way as --start-time, but specify the end-time of the output.',
    '-t' : "Specifies a duration with first N as hours, second as minutes, third as seconds. Values for minutes and seconds are optional. A duration will be interpreted as starting with the point of start-time or ending with the point of end-time. If neither a start-time nore an end-time is given, end of logfile is taken as end-time.",
    '-w' : 'Like --time-span, but starts with weeks.',
    '-d' : 'Like --time-span, but start with days.',
    '-H' : 'Like --time-span, but start with hours.',
    '-m' : 'Like --time-span, but start with minutes.',
    '-D' : 'Print the log of a specified day.',
    '-S' : 'use FORMATSTRING to parse the date ("%%Y-%%m-%%d %%H:%%M:%%S")',
    '-g' : 'Only lines where PATTERN was found will be printed.',
}

def isfile(value):
    """Check if value is a file and raise an Error if not.
    """
    if os.path.isfile(value): return value
    else: raise argparse.ArgumentTypeError('{0} is no file'.format(value))

def main():
    """Commandline tool to get time-specific access to logfiles using logscanlib.
    """
    parser = argparse.ArgumentParser(
        prog='logscan',
        description=INFO['description'],
        usage=INFO['usage'],
    )
    parser.add_argument('logfile', type=isfile)
    parser.add_argument(
        '-i',
        '--info',
        action='store_true',
        default=False,
        help=INFO['-i'],
    )
    parser.add_argument(
        '-s',
        '--start-time',
        action=ParseNofDateTimeDelta,
        nargs='+',
        metavar='VALUE',
        help=INFO['-s'],
    )
    parser.add_argument(
        '-e',
        '--end-time',
        action=ParseNofDateTimeDelta,
        nargs='+',
        metavar='VALUE',
        help=INFO['-e']
    )
    parser.add_argument(
        '-t',
        '--time-span',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-t']
    )
    parser.add_argument(
        '-w',
        '--weeks',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-w']
    )
    parser.add_argument(
        '-d',
        '--days',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-d']
    )
    parser.add_argument(
        '-H',
        '--hours',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-H']
    )
    parser.add_argument(
        '-m',
        '--minutes',
        action=ParseTimeDelta,
        nargs='+',
        default=timedelta(),
        metavar='N',
        help=INFO['-m']
    )
    parser.add_argument(
        '-D',
        '--date',
        action=ParseDate,
        nargs='+',
        metavar='N',
        help=INFO['-D']
    )
    parser.add_argument(
        '-S',
        '--strf',
        type=str,
        metavar='FORMATSTRING',
        help=INFO['-S']
    )
    parser.add_argument(
        '-g',
        '--grep',
        type=str,
        metavar='PATTERN',
        help=INFO['-g']
    )

    args = parser.parse_args()
    log = Logs(args.logfile, args.strf)
    log.period()
#    print log.end
#    print log.start

    if args.info:
        print ''
        print os.path.basename(log.path) + ':'
        print '{0} files'.format(log.number_files)
        print 'start: {0}'.format(log.start)
        print 'end: {0}'.format(log.end)
        print ''
        return

    if args.date:
        start = datetime.combine(args.date, time())
        end = datetime.combine(args.date + timedelta(days=1), time())
    else:
        delta = args.weeks + args.days + args.hours + args.minutes + args.time_span
        start = args.start_time
        styp = type(start).__name__
        end = args.end_time
        etyp = type(end).__name__

        if styp == 'timedelta': start = log.end - start
        elif styp == 'time': start = datetime.combine(log.end.date(), start)
        if etyp == 'timedelta': end = log.end - end
        elif etyp == 'time': end = datetime.combine(log.end.date(), end)

        if delta:
            if not start and not end:
                start = log.end - delta
                end = log.end
            elif start and not end:
                end = start + delta
            elif end and not start:
                start = end - delta
        else:
            if not start: start = log.start
            if not end: end = log.end

    lines = log.section(start, end)
    if lines:
        if args.grep: lines = [l for l in lines if args.grep in l]
        try: print ''.join(lines)[:-1]
        except IOError, KeyboardInterrupt: return
    else: print 'no log between {0} and {1}'.format(start, end)

if __name__ == "__main__":
    main()

